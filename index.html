<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Fortune Cookie (FOCO) Mint</title>
  <style>
    :root{
      --bg:#0a0f20; --card:#12183a; --text:#eef2ff; --muted:#9fb0da;
      --cookie:#C58E4B; --cookie2:#F0C27B; --cookie3:#8a5a2c;
      --primary:#6b7bff; --primary2:#9b6bff; --sugar:#ffe8be;
      --ring:rgba(107,123,255,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--text);
      font-family: ui-sans-serif, system-ui, "Segoe UI", Inter, Roboto, Arial, sans-serif;
      display:flex; justify-content:center; align-items:flex-start;

      /* BIG fortune cookies background */
      background:
        radial-gradient(1200px 800px at 70% -10%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(900px 600px at -20% 120%, rgba(155,107,255,.18), transparent 60%),
        url("data:image/svg+xml;utf8,\
        <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 260 260'>\
          <rect width='260' height='260' fill='none'/>\
          <g opacity='0.22'>\
            <path d='M70 120 Q130 58 190 120 Q130 182 70 120 Z' fill='%23C58E4B'/>\
            <rect x='165' y='93' width='70' height='10' rx='3' fill='%23ffffff' transform='rotate(18 200 98)'/>\
          </g>\
        </svg>");
      background-size:auto, auto, 340px 340px;
      animation:bgfloat 24s linear infinite;
    }
    @keyframes bgfloat{
      0%{background-position:0 0, 0 0, 0 0}
      50%{background-position:0 0, 0 0, 180px 140px}
      100%{background-position:0 0, 0 0, 0 0}
    }
    .card{
      width:100%; max-width:800px; margin:6vh 18px; background:var(--card);
      border-radius:22px; padding:28px; box-shadow:0 18px 40px rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.08); position:relative; overflow:hidden;
      backdrop-filter:saturate(1.1) blur(0.3px);
    }
    .cookie-top, .cookie-bottom{
      position:absolute; width:120px; height:120px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, var(--cookie2), var(--cookie));
      box-shadow: inset 0 6px 18px rgba(0,0,0,.25), 0 8px 24px rgba(0,0,0,.25);
      opacity:.25; filter: blur(0.2px);
    }
    .cookie-top{ right:-40px; top:-40px; transform:rotate(-18deg)}
    .cookie-bottom{ left:-50px; bottom:-50px; transform:rotate(22deg)}
    .choc{
      position:absolute; width:8px; height:8px; border-radius:50%; background:var(--cookie3);
      box-shadow: 14px 8px 0 var(--cookie3), 26px -3px 0 var(--cookie3),
                  48px 10px 0 var(--cookie3), 64px -2px 0 var(--cookie3);
      opacity:.45;
    }
    .choc.t{ right:30px; top:24px}
    .choc.b{ left:30px; bottom:28px}

    .ribbon{
      position:absolute; inset:auto -46px -40px auto; transform:rotate(-18deg);
      background:linear-gradient(135deg, var(--sugar), var(--cookie));
      color:#5a3c1b; padding:8px 20px; border-radius:14px; font-weight:800;
      box-shadow:0 6px 18px rgba(197,142,75,.35);
    }

    h1{margin:0 0 6px; font-size:30px; letter-spacing:.2px}
    .sub{color:var(--muted); font-size:14px}

    .rows{display:grid; grid-auto-rows:minmax(28px,auto); gap:12px; margin:20px 0}
    .row{display:flex; justify-content:space-between; align-items:center; gap:10px}
    .pill{
      background:#0e1432; padding:10px 12px; border-radius:14px; border:1px solid #26305b;
      min-width:170px; text-align:right; font-variant-numeric:tabular-nums;
      box-shadow:inset 0 1px 0 rgba(255,255,255,.06);
    }

    .footer{display:flex; gap:12px; align-items:center; margin-top:16px; flex-wrap:wrap}
    .btn{
      border:0; color:#fff; padding:12px 18px; border-radius:16px; cursor:pointer; font-weight:800;
      background:linear-gradient(135deg, #f7b267, #f79d65, #f4845f);
      box-shadow:0 10px 22px rgba(244,132,95,.35), inset 0 0 0 1px rgba(255,255,255,.12);
      transition:transform .05s ease, filter .2s ease;
    }
    .btn.purple{
      background:linear-gradient(135deg, var(--primary), var(--primary2));
      box-shadow:0 10px 22px var(--ring), inset 0 0 0 1px rgba(255,255,255,.12);
    }
    .btn:hover{filter:brightness(1.05)}
    .btn:active{transform:translateY(1px)}
    .btn:disabled{opacity:.6; cursor:not-allowed}
    .muted{color:var(--muted); font-size:14px}
    a{color:#bcd1ff; text-decoration:underline}
    .addr{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
    .copyable{cursor:pointer; user-select:all}
    .hint{font-size:12px; color:var(--muted); margin-top:2px; text-align:right}

    /* Loading overlay */
    .overlay{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(10,15,32,.55); z-index:50; backdrop-filter:blur(2px);
    }
    .overlay.show{display:flex}
    .spinner{
      width:64px; height:64px; border-radius:50%;
      background:
        radial-gradient(circle at 35% 35%, #fff 10%, transparent 11%) 8px 8px/18px 18px no-repeat,
        radial-gradient(circle at 65% 70%, #fff 10%, transparent 11%) 2px 0/18px 18px no-repeat,
        conic-gradient(from 0deg, var(--cookie) 0 120deg, var(--cookie2) 120deg 240deg, var(--cookie3) 240deg 360deg);
      animation:spin 1.1s linear infinite;
      box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 0 18px rgba(0,0,0,.25);
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    .overlay-text{margin-top:14px; color:#fff; font-weight:700; text-shadow:0 2px 10px rgba(0,0,0,.4)}
  </style>
</head>
<body>
  <div class="card">
    <div class="cookie-top"></div><div class="choc t"></div>
    <div class="cookie-bottom"></div><div class="choc b"></div>

    <div class="ribbon">ðŸ¥  Fortune Time</div>
    <h1>Fortune Cookie (FOCO) Mint</h1>
    <div class="sub">Connect a wallet and mint in one click.</div>

    <div class="rows">
      <div class="row"><div class="muted">Account</div><div id="account" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Network / Chain ID</div><div id="network" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Price (per mint)</div><div id="price" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Tokens per mint</div><div id="perMint" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Max per tx</div><div id="maxPerTx" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Wallet limit</div><div id="walletLimit" class="pill">â€”</div></div>
      <div class="row"><div class="muted">You minted</div><div id="youMinted" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Remaining FOCO Balance</div><div id="remaining" class="pill">â€”</div></div>

      <!-- Token CA (click to copy) + separate explorer link -->
      <div class="row">
        <div class="muted">Token (CA)</div>
        <div style="display:flex; flex-direction:column; align-items:flex-end">
          <div id="tokenCA" class="pill addr copyable" title="Click to copy">â€”</div>
          <div class="hint"><a id="tokenExplorerLink" href="#" target="_blank" rel="noreferrer">Open in Explorer</a></div>
        </div>
      </div>
    </div>

    <div class="footer">
      <button id="connectBtn" class="btn">Connect Wallet</button>
      <button id="mintBtn" class="btn purple" disabled>Mint</button>
      <div id="status" class="muted"></div>
    </div>
  </div>

  <!-- Loading overlay -->
  <div id="overlay" class="overlay">
    <div style="display:flex; flex-direction:column; align-items:center">
      <div class="spinner"></div>
      <div id="overlayText" class="overlay-text">Brewing fortunesâ€¦</div>
    </div>
  </div>

  <!-- Web3-Onboard UMD -->
  <script src="https://unpkg.com/@web3-onboard/core/dist/umd/index.min.js"></script>
  <script src="https://unpkg.com/@web3-onboard/injected-wallets/dist/umd/index.min.js"></script>
  <script src="https://unpkg.com/@web3-onboard/walletconnect/dist/umd/index.min.js"></script>

  <script>
    // ====== Config (your values) ======
    const MINTER_ADDRESS = "0xDFc2f53fb430e64bB11841fbf8F697d179B53f7d";
    const WC_PROJECT_ID  = "fe5cba6a3f99f7da13a7f4d58d9bee81";
    const TOKEN_CA_FALLBACK = "0x686eB0B1B2C888C673b4C20A625bD96E17261119";

    const GIWA = {
      chainId: '0x164ce', // 91342
      chainName: 'GIWA Sepolia',
      rpcUrls: ['https://sepolia-rpc.giwa.io'],
      nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
      blockExplorerUrls: ['https://sepolia-explorer.giwa.io']
    };

    // ABI superset (supports multiple minter variants)
    const MINTER_ABI = [
      // price getters
      "function priceWei() view returns (uint256)",
      "function PRICE() view returns (uint256)",
      "function pricePerTokenWei() view returns (uint256)",
      // per-mint amount getters
      "function tokensPerMintHuman() view returns (uint256)",
      "function TOKENS_PER_MINT() view returns (uint256)",
      "function tokensPerMint() view returns (uint256)",
      // limits & accounting
      "function maxPerTxHuman() view returns (uint256)",
      "function maxPerWalletHuman() view returns (uint256)",
      "function mintedHuman(address) view returns (uint256)",
      "function minted(address) view returns (uint256)",
      // token + mint
      "function token() view returns (address)",
      "function mint() payable"
    ];

    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function decimals() view returns (uint8)",
      "function symbol() view returns (string)"
    ];

    // ----- Helpers -----
    const q = id => document.getElementById(id);
    const statusEl = q("status");
    const accountEl = q("account"), networkEl = q("network"), priceEl = q("price");
    const perMintEl = q("perMint"), maxPerTxEl = q("maxPerTx"), walletLimitEl = q("walletLimit");
    const youMintedEl = q("youMinted"), remainingEl = q("remaining");
    const tokenCAEl = q("tokenCA"), tokenExplorerLinkEl = q("tokenExplorerLink");
    const connectBtn = q("connectBtn"), mintBtn = q("mintBtn");
    const overlay = q("overlay"), overlayText = q("overlayText");

    const fmt = (n, d=0) => { try { return Number(n).toLocaleString("en-US",{maximumFractionDigits:d}); } catch { return String(n); } };
    const short = a => a ? a.slice(0,6)+"â€¦"+a.slice(-4) : "â€”";
    const setLoading = (on, text) => { if (text) overlayText.textContent = text; overlay.classList[on ? 'add' : 'remove']('show'); };

    // Clipboard copy
    async function copyToClipboard(text){
      try{ await navigator.clipboard.writeText(text); return true; }
      catch{ const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta);
             ta.select(); const ok=document.execCommand('copy'); document.body.removeChild(ta); return ok; }
    }

    // load ethers with fallback CDNs
    function loadScript(src){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.async=false;s.onload=res;s.onerror=()=>rej(new Error('Failed '+src));document.head.appendChild(s);});}
    async function ensureEthers(){
      if (window.ethers) return;
      try { await loadScript("https://cdnjs.cloudflare.com/ajax/libs/ethers/6.11.1/ethers.umd.min.js"); } catch(e){}
      if (!window.ethers) { try { await loadScript("https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.min.js"); } catch(e){} }
      if (!window.ethers) throw new Error("Failed to load ethers.js");
    }

    // Onboard helpers
    const getOnboardCtor=()=> (window.Onboard?.default||window.Onboard||window.OnboardCore?.Onboard||null);
    const getInjected = ()=> (window.OnboardInjectedWallets?.default||window.OnboardInjectedWallets||null);
    const getWC       = ()=> (window.OnboardWalletConnect?.default||window.OnboardWalletConnect||null);

    let onboard, provider, signer, minter, token, tokenDec=18, tokenSym="FOCO";
    let priceWei=0n, perMint=0n, maxPerWallet=0n, maxPerTx=0n;

    // Try multiple function names until one succeeds
    async function tryUint(methods, ...args){
      for (const m of methods){
        if (!minter[m]) continue;
        try{
          const v = await minter[m](...args);
          if (v !== undefined && v !== null) return BigInt(v.toString());
        }catch(e){ /* try next */ }
      }
      throw new Error(`None of [${methods.join(", ")}] worked`);
    }

    function prettyError(e){
      const txt = e?.shortMessage || e?.reason || e?.message || e?.info?.error?.message || e?.error?.message;
      if (txt) return txt;
      try { return JSON.stringify(e); } catch { return "Transaction failed"; }
    }

    // Handle SOLD OUT state
    function applySoldOutIfNeeded(remainingHuman){
      if (remainingHuman === 0n){
        remainingEl.textContent = "0 " + tokenSym;
        statusEl.textContent = "Sold Out";
        mintBtn.disabled = true;
        return true;
      }
      return false;
    }

    async function init(){
      try{
        await ensureEthers();
        const OnboardCtor = getOnboardCtor();
        const injectedF = getInjected();
        const wcF = getWC();

        if (OnboardCtor && injectedF){
          const wallets = [ injectedF() ];
          if (wcF) { try { wallets.push(wcF({ projectId: WC_PROJECT_ID })); } catch(e){} }
          onboard = OnboardCtor({
            wallets,
            chains: [{ id: GIWA.chainId, token: GIWA.nativeCurrency.symbol, label: GIWA.chainName, rpcUrl: GIWA.rpcUrls[0] }],
            appMetadata: { name:"FOCO Mint", description:"Mint Fortune Cookie (FOCO) tokens" }
          });
        }

        // seed CA UI with fallback & copy behavior
        const href = `${GIWA.blockExplorerUrls[0].replace(/\/$/,'')}/address/${TOKEN_CA_FALLBACK}`;
        tokenCAEl.textContent = TOKEN_CA_FALLBACK;
        tokenExplorerLinkEl.href = href;
        tokenCAEl.addEventListener('click', async () => {
          const txt = tokenCAEl.textContent.trim();
          const ok = await copyToClipboard(txt);
          const old = tokenCAEl.textContent;
          tokenCAEl.textContent = ok ? "Copied!" : "Copy failed";
          setTimeout(()=> tokenCAEl.textContent = old, 900);
        });

      }catch(e){ statusEl.textContent = prettyError(e) || "Init error"; }
    }

    async function connect(){
      try{
        await ensureEthers();
        setLoading(true, "Connecting walletâ€¦");
        connectBtn.disabled = true;

        let eip1193;
        if (onboard){
          const wallets = await onboard.connectWallet();
          if (!wallets || !wallets.length) throw new Error("No wallet selected");
          const w = wallets[0];
          await onboard.setChain({ chainId: GIWA.chainId, wallet: w.label });
          eip1193 = w.provider;
        } else {
          if (!window.ethereum) throw new Error("No wallet provider found");
          eip1193 = window.ethereum;
          const tmp = new ethers.BrowserProvider(eip1193);
          const net = await tmp.getNetwork();
          if (net.chainId !== BigInt(parseInt(GIWA.chainId,16))){
            try { await eip1193.request({ method:'wallet_switchEthereumChain', params:[{ chainId: GIWA.chainId }] }); }
            catch(e){ if (e.code === 4902) await eip1193.request({ method:'wallet_addEthereumChain', params:[GIWA] }); else throw e; }
          }
          await eip1193.request({ method:'eth_requestAccounts' });
        }

        provider = new ethers.BrowserProvider(eip1193);
        signer = await provider.getSigner();
        const addr = await signer.getAddress();
        accountEl.textContent = short(addr);

        const net2 = await provider.getNetwork();
        networkEl.textContent = `${String(Number(net2.chainId))} / ${GIWA.chainName}`;

        minter = new ethers.Contract(MINTER_ADDRESS, MINTER_ABI, signer);

        setLoading(true, "Reading on-chain configâ€¦");

        // Read config (supports old/new names)
        priceWei = await tryUint(["priceWei","PRICE","pricePerTokenWei"]);
        perMint  = await tryUint(["tokensPerMintHuman","TOKENS_PER_MINT","tokensPerMint"]);
        try { maxPerWallet = await tryUint(["maxPerWalletHuman"]); } catch { maxPerWallet = 0n; }
        try { maxPerTx     = await tryUint(["maxPerTxHuman"]); } catch { maxPerTx = 0n; }

        let youMinted = 0n;
        try { youMinted = await tryUint(["mintedHuman","minted"], addr); } catch {}

        const tokenAddr = (await minter.token().catch(()=>null)) || TOKEN_CA_FALLBACK;
        token = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
        try { tokenDec = await token.decimals(); } catch{}
        try { tokenSym = await token.symbol(); } catch{}

        const rawBal = await token.balanceOf(MINTER_ADDRESS);
        const remainingHuman = rawBal / (10n ** BigInt(tokenDec));

        priceEl.textContent = ethers.formatEther(priceWei) + " " + GIWA.nativeCurrency.symbol;
        perMintEl.textContent = fmt(perMint) + " " + tokenSym;
        maxPerTxEl.textContent = (maxPerTx==0n) ? "Unlimited" : (fmt(maxPerTx) + " " + tokenSym);
        walletLimitEl.textContent = (maxPerWallet==0n) ? "Unlimited" : (fmt(maxPerWallet) + " " + tokenSym);
        youMintedEl.textContent  = fmt(youMinted) + " " + tokenSym;
        remainingEl.textContent  = fmt(remainingHuman) + " " + tokenSym;

        tokenCAEl.textContent = tokenAddr;
        tokenExplorerLinkEl.href = `${GIWA.blockExplorerUrls[0].replace(/\/$/,'')}/address/${tokenAddr}`;

        // SOLD OUT check first
        if (applySoldOutIfNeeded(remainingHuman)) {
          // keep connect disabled; mint already disabled
        } else if (maxPerTx>0n && perMint>maxPerTx){
          statusEl.textContent = `Config error: tokensPerMint (${perMint}) > maxPerTx (${maxPerTx}).`;
          mintBtn.disabled = true;
        } else {
          statusEl.textContent = "Ready";
          mintBtn.disabled = false;
        }

        // lock the connect button
        connectBtn.disabled = true;
        connectBtn.textContent = "Connected";
      }catch(e){
        statusEl.textContent = prettyError(e) || "Connection error";
        connectBtn.disabled = false; // allow retry
      } finally {
        setLoading(false);
      }
    }

    async function mint(){
      try{
        await ensureEthers();
        mintBtn.disabled = true;
        statusEl.textContent = "Simulatingâ€¦";

        // simulate first to catch reverts cleanly
        try {
          await minter.mint.staticCall({ value: priceWei });
        } catch (sim) {
          statusEl.textContent = "Reverted: " + prettyError(sim);
          mintBtn.disabled = false;
          return;
        }

        statusEl.textContent = "Sending transactionâ€¦";
        const tx = await minter.mint({ value: priceWei });
        statusEl.textContent = "Waiting for confirmationâ€¦";
        await tx.wait();

        const href = `${GIWA.blockExplorerUrls[0].replace(/\/$/,'')}/tx/${tx.hash}`;
        statusEl.innerHTML = `Done âœ… Tx: <a target="_blank" href="${href}" rel="noreferrer">${tx.hash.slice(0,10)}â€¦</a>`;

        const addr = await signer.getAddress();
        let youMinted = 0n;
        try { youMinted = await tryUint(["mintedHuman","minted"], addr); } catch {}
        youMintedEl.textContent = fmt(youMinted) + " " + tokenSym;

        const rawBal = await token.balanceOf(MINTER_ADDRESS);
        const remainingHuman = rawBal / (10n ** BigInt(tokenDec));
        remainingEl.textContent = fmt(remainingHuman) + " " + tokenSym;

        // SOLD OUT after mint?
        applySoldOutIfNeeded(remainingHuman);
      }catch(e){
        statusEl.textContent = prettyError(e) || "Mint failed";
      } finally {
        // re-enable mint only if not sold out
        if (!/Sold Out/i.test(statusEl.textContent)) mintBtn.disabled = false;
      }
    }

    // Boot
    (function init(){
      // initial CA + copy behavior set here too (in case wallet never connects)
      const href = `${GIWA.blockExplorerUrls[0].replace(/\/$/,'')}/address/${TOKEN_CA_FALLBACK}`;
      tokenCAEl.textContent = TOKEN_CA_FALLBACK;
      tokenExplorerLinkEl.href = href;
      tokenCAEl.addEventListener('click', async () => {
        const txt = tokenCAEl.textContent.trim();
        const ok = await copyToClipboard(txt);
        const old = tokenCAEl.textContent;
        tokenCAEl.textContent = ok ? "Copied!" : "Copy failed";
        setTimeout(()=> tokenCAEl.textContent = old, 900);
      });

      // web3-onboard init
      (async () => {
        try {
          await ensureEthers();
          const OnboardCtor = getOnboardCtor();
          const injectedF = getInjected();
          const wcF = getWC();
          if (OnboardCtor && injectedF){
            const wallets = [ injectedF() ];
            if (wcF) { try { wallets.push(wcF({ projectId: WC_PROJECT_ID })); } catch(e){} }
            onboard = OnboardCtor({
              wallets,
              chains: [{ id: GIWA.chainId, token: GIWA.nativeCurrency.symbol, label: GIWA.chainName, rpcUrl: GIWA.rpcUrls[0] }],
              appMetadata: { name:"FOCO Mint", description:"Mint Fortune Cookie (FOCO) tokens" }
            });
          }
        } catch(e){ statusEl.textContent = prettyError(e) || "Init error"; }
      })();

      q("connectBtn").onclick = connect;
      q("mintBtn").onclick = mint;
    })();
  </script>
</body>
</html>
