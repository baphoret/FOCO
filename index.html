<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>FOCO Mint</title>
  <style>
    :root{
      --bg:#090e1f; --card:#131a3b; --text:#e9efff; --muted:#9fb0da;
      --primary:#6b7bff; --primary2:#9b6bff; --accent:#C58E4B; --accent2:#ffd9a3;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--text);
      font-family: ui-sans-serif, system-ui, "Segoe UI", Roboto, Inter, Arial, sans-serif;
      display:flex; justify-content:center; align-items:flex-start;

      /* BIG fortune cookies background */
      background:
        radial-gradient(1200px 800px at 70% -10%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(900px 600px at -20% 120%, rgba(155,107,255,.18), transparent 60%),
        url("data:image/svg+xml;utf8,\
        <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 220 220'>\
          <rect width='220' height='220' fill='none'/>\
          <g opacity='0.22'>\
            <path d='M60 100 Q110 50 160 100 Q110 150 60 100 Z' fill='%23C58E4B'/>\
            <rect x='135' y='78' width='54' height='9' rx='2' fill='%23ffffff' transform='rotate(18 162 82)'/>\
          </g>\
        </svg>");
      background-size:auto, auto, 300px 300px;
      animation:bgfloat 24s linear infinite;
    }
    @keyframes bgfloat{
      0%{background-position:0 0, 0 0, 0 0}
      50%{background-position:0 0, 0 0, 160px 130px}
      100%{background-position:0 0, 0 0, 0 0}
    }
    .card{
      width:100%; max-width:760px; margin:6vh 18px; background:var(--card);
      border-radius:18px; padding:26px; box-shadow:0 18px 40px rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.08); position:relative; overflow:hidden;
    }
    .ribbon{
      position:absolute; inset:auto -40px -40px auto; transform:rotate(-18deg);
      background:linear-gradient(135deg, var(--accent2), var(--accent)); color:#5a3c1b;
      padding:6px 18px; border-radius:12px; font-weight:800; box-shadow:0 4px 16px rgba(197,142,75,.35);
    }
    h1{margin:0 0 6px; font-size:28px; letter-spacing:.2px}
    .sub{color:var(--muted); font-size:14px}
    .rows{display:grid; grid-auto-rows:minmax(28px,auto); gap:12px; margin:18px 0}
    .row{display:flex; justify-content:space-between; align-items:center; gap:10px}
    .pill{
      background:#0f1533; padding:8px 12px; border-radius:12px; border:1px solid #2a335f;
      min-width:160px; text-align:right; font-variant-numeric:tabular-nums;
    }
    .footer{display:flex; gap:12px; align-items:center; margin-top:14px; flex-wrap:wrap}
    .btn{
      border:0; color:#fff; padding:12px 16px; border-radius:14px; cursor:pointer; font-weight:800;
      background:linear-gradient(135deg, var(--primary), var(--primary2));
      box-shadow:0 10px 22px rgba(107,123,255,.35), inset 0 0 0 1px rgba(255,255,255,.1);
      transition:transform .05s ease, filter .2s ease;
    }
    .btn:hover{filter:brightness(1.05)}
    .btn:active{transform:translateY(1px)}
    .btn:disabled{opacity:.6; cursor:not-allowed}
    .muted{color:var(--muted); font-size:14px}
    a{color:#bcd1ff; text-decoration:underline}
    .addr{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
  </style>
</head>
<body>
  <div class="card">
    <div class="ribbon">ðŸ¥  Fortune Time</div>
    <h1>Fortune Cookie (FOCO) â€” Mint</h1>
    <div class="sub">Connect a wallet (MetaMask, Rabby, or WalletConnect) and mint in one click.</div>

    <div class="rows">
      <div class="row"><div class="muted">Account</div><div id="account" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Network / Chain ID</div><div id="network" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Price (per mint)</div><div id="price" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Tokens per mint</div><div id="perMint" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Wallet limit</div><div id="walletLimit" class="pill">â€”</div></div>
      <div class="row"><div class="muted">You minted</div><div id="youMinted" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Minter balance (remaining)</div><div id="remaining" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Token (CA)</div><div id="tokenCA" class="pill addr">â€”</div></div>
    </div>

    <div class="footer">
      <button id="connectBtn" class="btn">Connect Wallet</button>
      <button id="mintBtn" class="btn" disabled>Mint</button>
      <div id="status" class="muted"></div>
    </div>
  </div>

  <!-- Web3-Onboard UMD -->
  <script src="https://unpkg.com/@web3-onboard/core/dist/umd/index.min.js"></script>
  <script src="https://unpkg.com/@web3-onboard/injected-wallets/dist/umd/index.min.js"></script>
  <script src="https://unpkg.com/@web3-onboard/walletconnect/dist/umd/index.min.js"></script>

  <script>
    // ====== Config (your values) ======
    const MINTER_ADDRESS = "0x5952EAD3fCB11251A9755abFE70A3290366D2603";
    const WC_PROJECT_ID  = "fe5cba6a3f99f7da13a7f4d58d9bee81";
    const TOKEN_CA_FALLBACK = "0x686eB0B1B2C888C673b4C20A625bD96E17261119"; // shown if minter.token() fails

    const GIWA = {
      chainId: '0x164ce', // 91342
      chainName: 'GIWA Sepolia',
      rpcUrls: ['https://sepolia-rpc.giwa.io'],
      nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
      blockExplorerUrls: ['https://sepolia-explorer.giwa.io']
    };

    // ABI superset (supports multiple minter variants)
    const MINTER_ABI = [
      // price getters
      "function priceWei() view returns (uint256)",
      "function PRICE() view returns (uint256)",
      "function pricePerTokenWei() view returns (uint256)",
      // per-mint amount getters
      "function tokensPerMintHuman() view returns (uint256)",
      "function TOKENS_PER_MINT() view returns (uint256)",
      "function tokensPerMint() view returns (uint256)",
      // limits & accounting
      "function maxPerTxHuman() view returns (uint256)",
      "function maxPerWalletHuman() view returns (uint256)",
      "function mintedHuman(address) view returns (uint256)",
      "function minted(address) view returns (uint256)",
      // token + mint
      "function token() view returns (address)",
      "function mint() payable"
    ];

    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function decimals() view returns (uint8)",
      "function symbol() view returns (string)"
    ];

    // ----- Helpers -----
    const q = id => document.getElementById(id);
    const statusEl = q("status");
    const accountEl = q("account"), networkEl = q("network"), priceEl = q("price");
    const perMintEl = q("perMint"), walletLimitEl = q("walletLimit"), youMintedEl = q("youMinted");
    const remainingEl = q("remaining"), tokenCAEl = q("tokenCA");
    const connectBtn = q("connectBtn"), mintBtn = q("mintBtn");

    const fmt = (n, d=0) => { try { return Number(n).toLocaleString("en-US",{maximumFractionDigits:d}); } catch { return String(n); } };
    const short = a => a ? a.slice(0,6)+"â€¦"+a.slice(-4) : "â€”";

    // load ethers with fallback CDNs
    function loadScript(src){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.async=false;s.onload=res;s.onerror=()=>rej(new Error('Failed '+src));document.head.appendChild(s);});}
    async function ensureEthers(){
      if (window.ethers) return;
      try { await loadScript("https://cdnjs.cloudflare.com/ajax/libs/ethers/6.11.1/ethers.umd.min.js"); } catch(e){}
      if (!window.ethers) { try { await loadScript("https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.min.js"); } catch(e){} }
      if (!window.ethers) throw new Error("Failed to load ethers.js");
    }

    // Onboard helpers
    const getOnboardCtor=()=> (window.Onboard?.default||window.Onboard||window.OnboardCore?.Onboard||null);
    const getInjected = ()=> (window.OnboardInjectedWallets?.default||window.OnboardInjectedWallets||null);
    const getWC       = ()=> (window.OnboardWalletConnect?.default||window.OnboardWalletConnect||null);

    let onboard, provider, signer, minter, token, tokenDec=18, tokenSym="FOCO";
    let priceWei=0n, perMint=0n, maxPerWallet=0n;

    // Try multiple function names until one succeeds
    async function tryUint(methods, ...args){
      for (const m of methods){
        if (!minter[m]) continue;
        try{
          const v = await minter[m](...args);
          if (v !== undefined && v !== null) return BigInt(v.toString());
        }catch(e){ /* try next */ }
      }
      throw new Error(`None of [${methods.join(", ")}] worked`);
    }

    // nicer error messages
    function prettyError(e){
      return (
        e?.shortMessage ||
        e?.reason ||
        e?.message ||
        e?.info?.error?.message ||
        e?.error?.message ||
        "Transaction failed"
      );
    }

    async function init(){
      try{
        await ensureEthers();
        const OnboardCtor = getOnboardCtor();
        const injectedF = getInjected();
        const wcF = getWC();

        if (OnboardCtor && injectedF){
          const wallets = [ injectedF() ];
          if (wcF) {
            try { wallets.push(wcF({ projectId: "fe5cba6a3f99f7da13a7f4d58d9bee81" })); } catch(e){}
          }
          onboard = OnboardCtor({
            wallets,
            chains: [{ id: GIWA.chainId, token: GIWA.nativeCurrency.symbol, label: GIWA.chainName, rpcUrl: GIWA.rpcUrls[0] }],
            appMetadata: { name:"FOCO Mint", description:"Mint Fortune Cookie (FOCO) tokens" }
          });
        }
        // show fallback token CA immediately
        const href = `${GIWA.blockExplorerUrls[0].replace(/\/$/,'')}/address/${TOKEN_CA_FALLBACK}`;
        tokenCAEl.innerHTML = `<a class="addr" target="_blank" href="${href}">${TOKEN_CA_FALLBACK}</a>`;
      }catch(e){ statusEl.textContent = prettyError(e) || "Init error"; }
    }

    async function connect(){
      try{
        await ensureEthers();
        let eip1193;

        if (onboard){
          const wallets = await onboard.connectWallet();
          if (!wallets || !wallets.length) throw new Error("No wallet selected");
          const w = wallets[0];
          await onboard.setChain({ chainId: GIWA.chainId, wallet: w.label });
          eip1193 = w.provider;
        } else {
          if (!window.ethereum) throw new Error("No wallet provider found");
          eip1193 = window.ethereum;
          const tmp = new ethers.BrowserProvider(eip1193);
          const net = await tmp.getNetwork();
          if (net.chainId !== BigInt(parseInt(GIWA.chainId,16))){
            try { await eip1193.request({ method:'wallet_switchEthereumChain', params:[{ chainId: GIWA.chainId }] }); }
            catch(e){ if (e.code === 4902) await eip1193.request({ method:'wallet_addEthereumChain', params:[GIWA] }); else throw e; }
          }
          await eip1193.request({ method:'eth_requestAccounts' });
        }

        provider = new ethers.BrowserProvider(eip1193);
        signer = await provider.getSigner();
        const addr = await signer.getAddress();
        accountEl.textContent = short(addr);

        const net2 = await provider.getNetwork();
        networkEl.textContent = `${String(Number(net2.chainId))} / ${GIWA.chainName}`;

        minter = new ethers.Contract(MINTER_ADDRESS, MINTER_ABI, signer);

        // Read config (supports old/new names)
        priceWei = await tryUint(["priceWei","PRICE","pricePerTokenWei"]);
        perMint  = await tryUint(["tokensPerMintHuman","TOKENS_PER_MINT","tokensPerMint"]);
        try { maxPerWallet = await tryUint(["maxPerWalletHuman"]); } catch { maxPerWallet = 0n; }

        let youMinted = 0n;
        try { youMinted = await tryUint(["mintedHuman","minted"], addr); } catch {}

        const tokenAddr = (await minter.token().catch(()=>null)) || TOKEN_CA_FALLBACK;
        token = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
        try { tokenDec = await token.decimals(); } catch{}
        try { tokenSym = await token.symbol(); } catch{}

        const rawBal = await token.balanceOf(MINTER_ADDRESS);
        const remainingHuman = rawBal / (10n ** BigInt(tokenDec));

        priceEl.textContent = ethers.formatEther(priceWei) + " " + GIWA.nativeCurrency.symbol;
        perMintEl.textContent = fmt(perMint) + " " + tokenSym;
        walletLimitEl.textContent = (maxPerWallet==0n) ? "Unlimited" : (fmt(maxPerWallet) + " " + tokenSym;
        youMintedEl.textContent  = fmt(youMinted) + " " + tokenSym;
        remainingEl.textContent  = fmt(remainingHuman) + " " + tokenSym;

        const tokenHref = `${GIWA.blockExplorerUrls[0].replace(/\/$/,'')}/address/${tokenAddr}`;
        tokenCAEl.innerHTML = `<a class="addr" target="_blank" href="${tokenHref}">${tokenAddr}</a>`;

        // UI: lock the connect button
        connectBtn.disabled = true;
        connectBtn.textContent = "Connected";
        mintBtn.disabled = false;
        statusEl.textContent = "Ready";
      }catch(e){
        statusEl.textContent = prettyError(e) || "Connection error";
      }
    }

    async function mint(){
      try{
        await ensureEthers();
        statusEl.textContent = "Sending transactionâ€¦";
        const tx = await minter.mint({ value: priceWei });
        statusEl.textContent = "Waiting for confirmationâ€¦";
        await tx.wait();
        const href = `${GIWA.blockExplorerUrls[0].replace(/\/$/,'')}/tx/${tx.hash}`;
        statusEl.innerHTML = `Done âœ… Tx: <a target="_blank" href="${href}" rel="noreferrer">${tx.hash.slice(0,10)}â€¦</a>`;

        const addr = await signer.getAddress();
        let youMinted = 0n;
        try { youMinted = await tryUint(["mintedHuman","minted"], addr); } catch {}
        youMintedEl.textContent = fmt(youMinted) + " " + tokenSym;

        const rawBal = await token.balanceOf(MINTER_ADDRESS);
        const remainingHuman = rawBal / (10n ** BigInt(tokenDec));
        remainingEl.textContent = fmt(remainingHuman) + " " + tokenSym;
      }catch(e){
        statusEl.textContent = prettyError(e) || "Mint failed";
      }
    }

    connectBtn.onclick = connect;
    mintBtn.onclick = mint;
    init();
  </script>
</body>
</html>
