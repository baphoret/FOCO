<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>FOCO Mint</title>
  <style>
    :root{
      --bg:#090e1f; --card:#131a3b; --text:#e9efff; --muted:#9fb0da;
      --primary:#6b7bff; --primary2:#9b6bff; --accent:#C58E4B; --accent2:#ffd9a3;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--text);
      font-family: ui-sans-serif, system-ui, "Segoe UI", Roboto, Inter, Arial, sans-serif;
      display:flex; justify-content:center; align-items:flex-start;

      /* BIG fortune cookies background */
      background:
        radial-gradient(1200px 800px at 70% -10%, rgba(255,255,255,.06), transparent 60%),
        radial-gradient(900px 600px at -20% 120%, rgba(155,107,255,.18), transparent 60%),
        url("data:image/svg+xml;utf8,\
        <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 220 220'>\
          <rect width='220' height='220' fill='none'/>\
          <g opacity='0.22'>\
            <path d='M60 100 Q110 50 160 100 Q110 150 60 100 Z' fill='%23C58E4B'/>\
            <rect x='135' y='78' width='54' height='9' rx='2' fill='%23ffffff' transform='rotate(18 162 82)'/>\
          </g>\
        </svg>");
      background-size:auto, auto, 300px 300px;
      animation:bgfloat 24s linear infinite;
    }
    @keyframes bgfloat{
      0%{background-position:0 0, 0 0, 0 0}
      50%{background-position:0 0, 0 0, 160px 130px}
      100%{background-position:0 0, 0 0, 0 0}
    }
    .card{
      width:100%; max-width:760px; margin:6vh 18px; background:var(--card);
      border-radius:18px; padding:26px; box-shadow:0 18px 40px rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.08); position:relative; overflow:hidden;
    }
    .ribbon{
      position:absolute; inset:auto -40px -40px auto; transform:rotate(-18deg);
      background:linear-gradient(135deg, var(--accent2), var(--accent)); color:#5a3c1b;
      padding:6px 18px; border-radius:12px; font-weight:800; box-shadow:0 4px 16px rgba(197,142,75,.35);
    }
    h1{margin:0 0 6px; font-size:28px; letter-spacing:.2px}
    .sub{color:var(--muted); font-size:14px}
    .rows{display:grid; grid-auto-rows:minmax(28px,auto); gap:12px; margin:18px 0}
    .row{display:flex; justify-content:space-between; align-items:center; gap:10px}
    .pill{
      background:#0f1533; padding:8px 12px; border-radius:12px; border:1px solid #2a335f;
      min-width:160px; text-align:right; font-variant-numeric:tabular-nums;
    }
    .footer{display:flex; gap:12px; align-items:center; margin-top:14px; flex-wrap:wrap}
    .btn{
      border:0; color:#fff; padding:12px 16px; border-radius:14px; cursor:pointer; font-weight:800;
      background:linear-gradient(135deg, var(--primary), var(--primary2));
      box-shadow:0 10px 22px rgba(107,123,255,.35), inset 0 0 0 1px rgba(255,255,255,.1);
      transition:transform .05s ease, filter .2s ease;
    }
    .btn:hover{filter:brightness(1.05)}
    .btn:active{transform:translateY(1px)}
    .btn:disabled{opacity:.6; cursor:not-allowed}
    .muted{color:var(--muted); font-size:14px}
    a{color:#bcd1ff; text-decoration:underline}
  </style>
</head>
<body>
  <div class="card">
    <div class="ribbon">ðŸ¥  Fortune Time</div>
    <h1>Fortune Cookie (FOCO) â€” Mint</h1>
    <div class="sub">Connect a wallet (MetaMask, Rabby, or WalletConnect) and mint in one click.</div>

    <div class="rows">
      <div class="row"><div class="muted">Account</div><div id="account" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Network / Chain ID</div><div id="network" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Price (per mint)</div><div id="price" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Tokens per mint</div><div id="perMint" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Wallet limit</div><div id="walletLimit" class="pill">â€”</div></div>
      <div class="row"><div class="muted">You minted</div><div id="youMinted" class="pill">â€”</div></div>
      <div class="row"><div class="muted">Minter balance (remaining)</div><div id="remaining" class="pill">â€”</div></div>
    </div>

    <div class="footer">
      <button id="connectBtn" class="btn">Connect Wallet</button>
      <button id="mintBtn" class="btn" disabled>Mint</button>
      <div id="status" class="muted"></div>
    </div>
  </div>

  <!-- Web3-Onboard UMD -->
  <script src="https://unpkg.com/@web3-onboard/core/dist/umd/index.min.js"></script>
  <script src="https://unpkg.com/@web3-onboard/injected-wallets/dist/umd/index.min.js"></script>
  <script src="https://unpkg.com/@web3-onboard/walletconnect/dist/umd/index.min.js"></script>

  <script>
    // ====== Config ======
    const MINTER_ADDRESS = "0x5952EAD3fCB11251A9755abFE70A3290366D2603"; // <-- replace
    const WC_PROJECT_ID  = "fe5cba6a3f99f7da13a7f4d58d9bee81"; // optional (shows WC if valid)

    const GIWA = {
      chainId: '0x164ce', // 91342
      chainName: 'GIWA Sepolia',
      rpcUrls: ['https://sepolia-rpc.giwa.io'],
      nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
      blockExplorerUrls: ['https://sepolia-explorer.giwa.io']
    };

    const MINTER_ABI = [
      "function token() view returns (address)",
      "function priceWei() view returns (uint256)",
      "function tokensPerMintHuman() view returns (uint256)",
      "function maxPerTxHuman() view returns (uint256)",
      "function maxPerWalletHuman() view returns (uint256)",
      "function mintedHuman(address) view returns (uint256)",
      "function mint() payable"
    ];
    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function decimals() view returns (uint8)",
      "function symbol() view returns (string)"
    ];

    // ----- Helpers -----
    const q = id => document.getElementById(id);
    const statusEl = q("status");
    const accountEl = q("account"), networkEl = q("network"), priceEl = q("price");
    const perMintEl = q("perMint"), walletLimitEl = q("walletLimit"), youMintedEl = q("youMinted");
    const remainingEl = q("remaining"), connectBtn = q("connectBtn"), mintBtn = q("mintBtn");
    const fmt = (n, d=0) => { try { return Number(n).toLocaleString("en-US",{maximumFractionDigits:d}); } catch { return String(n); } };
    const short = a => a ? a.slice(0,6)+"â€¦"+a.slice(-4) : "â€”";

    // Dynamically load a script (with fallback CDNs)
    function loadScript(src){ return new Promise((res, rej)=>{ const s=document.createElement('script'); s.src=src; s.async=false; s.onload=res; s.onerror=()=>rej(new Error('Failed: '+src)); document.head.appendChild(s); }); }

    // Ensure ethers is present (try cdnjs then jsDelivr)
    async function ensureEthers(){
      if (window.ethers) return;
      try { await loadScript("https://cdnjs.cloudflare.com/ajax/libs/ethers/6.11.1/ethers.umd.min.js"); }
      catch(e){ console.warn(e); }
      if (!window.ethers) {
        try { await loadScript("https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.min.js"); }
        catch(e){ console.warn(e); }
      }
      if (!window.ethers) throw new Error("Failed to load ethers.js");
    }

    // Onboard UMD helpers
    function getOnboardCtor(){
      if (window.Onboard && typeof window.Onboard === 'function') return window.Onboard;
      if (window.Onboard && typeof window.Onboard.default === 'function') return window.Onboard.default;
      if (window.OnboardCore && typeof window.OnboardCore.Onboard === 'function') return window.OnboardCore.Onboard;
      return null;
    }
    function getInjectedFactory(){ const m=window.OnboardInjectedWallets; return m ? (m.default||m) : null; }
    function getWalletConnectFactory(){ const m=window.OnboardWalletConnect; return m ? (m.default||m) : null; }

    let onboard, provider, signer, minter, token, tokenDec=18, tokenSym="FOCO";
    let priceWei=0n, perMint=0n, maxPerWallet=0n;

    // Init Onboard after ethers is ready
    async function init(){
      try{
        await ensureEthers();

        const OnboardCtor = getOnboardCtor();
        const injectedFactory = getInjectedFactory();
        const wcFactory = getWalletConnectFactory();

        if (OnboardCtor && injectedFactory) {
          const wallets = [ injectedFactory() ];
          if (WC_PROJECT_ID && !WC_PROJECT_ID.startsWith('YOUR_') && wcFactory) {
            try { wallets.push(wcFactory({ projectId: WC_PROJECT_ID })); } catch(e){ console.warn("WC init failed:", e); }
          }
          onboard = OnboardCtor({
            wallets,
            chains: [{ id: GIWA.chainId, token: GIWA.nativeCurrency.symbol, label: GIWA.chainName, rpcUrl: GIWA.rpcUrls[0] }],
            appMetadata: {
              name: "FOCO Mint",
              description: "Mint Fortune Cookie (FOCO) tokens",
              recommendedInjectedWallets: [
                { name: 'MetaMask', url: 'https://metamask.io' },
                { name: 'Rabby', url: 'https://rabby.io' }
              ]
            }
          });
        } else {
          console.warn("Onboard not available â€” will use injected provider fallback.");
        }
      }catch(e){
        console.error(e);
        statusEl.textContent = e.message || "Init error";
      }
    }

    async function connect(){
      try{
        await ensureEthers();

        let eip1193;
        if (onboard) {
          const wallets = await onboard.connectWallet();
          if (!wallets || !wallets.length) throw new Error("No wallet selected");
          const wallet = wallets[0];
          await onboard.setChain({ chainId: GIWA.chainId, wallet: wallet.label });
          eip1193 = wallet.provider;
        } else {
          if (!window.ethereum) throw new Error("No wallet provider found");
          eip1193 = window.ethereum;
          const tmp = new ethers.BrowserProvider(eip1193);
          const net = await tmp.getNetwork();
          if (net.chainId !== BigInt(parseInt(GIWA.chainId,16))) {
            try {
              await eip1193.request({ method:'wallet_switchEthereumChain', params:[{ chainId: GIWA.chainId }] });
            } catch (e) {
              if (e.code === 4902) await eip1193.request({ method:'wallet_addEthereumChain', params:[GIWA] });
              else throw e;
            }
          }
          await eip1193.request({ method:'eth_requestAccounts' });
        }

        provider = new ethers.BrowserProvider(eip1193);
        signer = await provider.getSigner();
        const addr = await signer.getAddress();
        accountEl.textContent = short(addr);

        const net2 = await provider.getNetwork();
        networkEl.textContent = `${String(Number(net2.chainId))} / ${GIWA.chainName}`;

        minter = new ethers.Contract(MINTER_ADDRESS, MINTER_ABI, signer);

        priceWei = await minter.priceWei();
        perMint  = await minter.tokensPerMintHuman();
        const maxPerTx = await minter.maxPerTxHuman(); // unused in UI
        maxPerWallet = await minter.maxPerWalletHuman();
        const youMinted = await minter.mintedHuman(addr);

        const tokenAddr = await minter.token();
        token = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
        tokenDec = await token.decimals().catch(()=>18);
        tokenSym = await token.symbol().catch(()=> "TOKEN");

        const rawBal = await token.balanceOf(MINTER_ADDRESS);
        const remainingHuman = rawBal / (10n ** BigInt(tokenDec));

        priceEl.textContent = ethers.formatEther(priceWei) + " " + GIWA.nativeCurrency.symbol;
        perMintEl.textContent = fmt(perMint) + " " + tokenSym;
        walletLimitEl.textContent = (maxPerWallet==0n) ? "Unlimited" : (fmt(maxPerWallet) + " " + tokenSym);
        youMintedEl.textContent = fmt(youMinted) + " " + tokenSym;
        remainingEl.textContent = fmt(remainingHuman) + " " + tokenSym;

        mintBtn.disabled = false;
        statusEl.textContent = "Ready";
      }catch(e){
        console.error(e);
        statusEl.textContent = e.shortMessage || e.message || "Connection error";
      }
    }

    async function mint(){
      try{
        await ensureEthers();
        statusEl.textContent = "Sending transactionâ€¦";
        const tx = await minter.mint({ value: priceWei });
        statusEl.textContent = "Waiting for confirmationâ€¦";
        const rc = await tx.wait();
        const href = `${GIWA.blockExplorerUrls[0].replace(/\/$/,'')}/tx/${tx.hash}`;
        statusEl.innerHTML = `Done âœ… Tx: <a target="_blank" href="${href}" rel="noreferrer">${tx.hash.slice(0,10)}â€¦</a>`;

        const addr = await signer.getAddress();
        const youMinted = await minter.mintedHuman(addr);
        youMintedEl.textContent = fmt(youMinted) + " " + tokenSym;
        const rawBal = await token.balanceOf(MINTER_ADDRESS);
        const remainingHuman = rawBal / (10n ** BigInt(tokenDec));
        remainingEl.textContent = fmt(remainingHuman) + " " + tokenSym;
      }catch(e){
        console.error(e);
        statusEl.textContent = e.shortMessage || e.message || "Mint failed";
      }
    }

    // Wire up buttons and init
    q("connectBtn").onclick = connect;
    q("mintBtn").onclick = mint;
    init();
  </script>
</body>
</html>
